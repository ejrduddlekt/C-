#include <iostream>
#include <string>
#include <cstdio>
#include <iostream>
using namespace std;

/*
인라인함수

함수를 호출하면 스텍메모리 사용이 증가하고 매개변수 때문에 메모리 복사가 일어납니다.
제어흐름도 이동해야 합니다. 코드만 살펴보면 드러나 보이지는 않지만 내부적으로는 
여러 연산들(매개변수 복사, 스텍조정, 제어 이동 등)이 일어나는 것이죠

보통 이같은 문제(함수 호출로 인한 오버헤드)를 극복하고자 메크로를 사용합니다. 
특히 길이가 짧고 단순한 것임에도 불구하고 관리 상의 목적때문에
만들어진 코드를 메크로로 변환할 경우 무시할 수 없는 수준의 성능 향상을 기대할 수 있습니다.

하지만 메크로는 함수가 아닙니다. 외형은 그렇게 보이지만 본질은 함수가 아니므로 다양한 논리적 오류를
발생시키기도 합니다.
게다가 매개변수에 형식을 지정할 수 없다는 점도 큰 문제입니다.

그래서 탄생한 것이 바로 인라인함수입니다.
인라인 함수는 매크로의 장점과 함수의 장점을 두루 갖춘 재주 많은 함수입니다.
본질적으로 함수이므로 매개변수에 형식을 지정할 수 있어 매크로의 단점을 보완해 줍니다. 
문법도 매우 간단해 함수 원형 앞에 inline이라는 예약어만 작성하면 끝납니다. 
그러나 내부적으로는 매크로처럼 함수 호출을 하지 않습니다.
결과적으로 함수와 매크로의 장점만 한 군데 모아놓은 것입니다.
*/


#define ADD(a,b)((a) + (b))

int Add(int a, int b) {
	return a + b;
}

inline int AddNew(int a, int b) 
{
	return a + b;
}

int main()
{
	int a, b;
	scanf_s("#d#d", &a, &b);

	printf("ADD(): %d \n", ADD(a, b));
	printf("Add(): %d \n", Add(a, b));
	printf("AddNew(): %d \n", AddNew(a, b));

	return 0;
}